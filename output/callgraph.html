<!DOCTYPE html>
<html>
<body>


<span style="font-size:24px;font-weight:bold;">Call Graph</span><br>
<canvas id="GraphCanvas" width="1500" height="400" style="border:1px solid #000000;"></canvas>
<br><br>
<span style="font-size:24px;font-weight:bold;">Local Variable Assignments</span><br>
<div style="width:800px;">Each row in the table below represents a byte of memory used to hold local variables by functions. Each block represents a local variable. Multiple blocks per row show that that byte of memory is being reused by multiple functions.
This scheme is very efficient compared to the main two alternatives: stack based addressing, which is slow and monopolizes processor resources, and allocating each byte to only one function, which wastes the scarce 256 bytes of fast zero page memory.
</div>
<table id="localtable" border="1" style='font-family:"Arial; font-size:14px'>
	<tr>
		<td>(none)</td>
	</tr>
</table>

<script>
	box_width=80;
	box_height=40;
	box_border_width=10;
	box_border_height=20;
	screen_border_width=20;
	screen_border_height=20;
	//box_alpha=0.5; //Looks good with solid colors (ie FF0000, 00FF00, etc) but need same color in table so no alpha
	box_alpha=1.0;
	
	boxlist=[];									//Empty list in case template loads without payload
	boxlist.push([0,0,"Test","10 bytes"]);		//Test data
	linelist=[];
	tabledata=[];
	graphwidth=0;
	graphheight=0;
	
	
	
	//Reload page automatically when focus switches to window
	//(can't reload page when optimizer writes new local file with javascript alone!)
	reload=false;
	setInterval(function()
	{ 
		if (!(document.hasFocus())) reload=true;
		else
		{
			if (reload) location.reload();
			reload=false;
		}
	},500);
	
boxlist=[];
linelist=[];
boxlist.push([11.5,0,'main','3 bytes']);
boxlist.push([0.0,1,'setup','0 bytes']);
boxlist.push([6.5,1,'DrawStack','4 bytes']);
boxlist.push([14.0,1,'ReadLine','5 bytes']);
boxlist.push([16.0,1,'LineWord','0 bytes']);
boxlist.push([17.0,1,'FindWord','0 bytes']);
boxlist.push([18.0,1,'ExecToken','5 bytes']);
boxlist.push([19.5,1,'ErrorMsg','3 bytes']);
boxlist.push([21.0,1,'CheckData','11 bytes']);
boxlist.push([22.0,1,'StackAddItem','0 bytes']);
boxlist.push([23.0,1,'MemCopy','5 bytes']);
boxlist.push([1.0,2,'LCD_clrscr','1 bytes']);
boxlist.push([2.0,2,'LCD_print','4 bytes']);
boxlist.push([3.0,2,'LCD_char','7 bytes']);
boxlist.push([6.0,2,'DrawFloat','7 bytes']);
boxlist.push([9.0,2,'DrawString','4 bytes']);
boxlist.push([11.0,2,'DrawHex','3 bytes']);
boxlist.push([13.0,2,'LCD_print','4 bytes']);
boxlist.push([14.0,2,'ReadKey','0 bytes']);
boxlist.push([15.0,2,'LCD_char','7 bytes']);
boxlist.push([18.0,2,'StackAddItem','0 bytes']);
boxlist.push([19.0,2,'LCD_print','4 bytes']);
boxlist.push([20.0,2,'ReadKey','0 bytes']);
boxlist.push([2.0,3,'LCD_char','7 bytes']);
boxlist.push([4.0,3,'MemCopy','5 bytes']);
boxlist.push([5.0,3,'BCD_Reverse','3 bytes']);
boxlist.push([6.0,3,'LCD_char','7 bytes']);
boxlist.push([7.0,3,'DigitHigh','1 bytes']);
boxlist.push([8.0,3,'DigitLow','1 bytes']);
boxlist.push([9.0,3,'LCD_char','7 bytes']);
boxlist.push([10.0,3,'LCD_char','7 bytes']);
boxlist.push([11.0,3,'HexHigh','2 bytes']);
boxlist.push([12.0,3,'HexLow','2 bytes']);
boxlist.push([13.0,3,'LCD_char','7 bytes']);
boxlist.push([19.0,3,'LCD_char','7 bytes']);
boxlist.push([7.0,4,'LCD_char','7 bytes']);
boxlist.push([8.0,4,'LCD_char','7 bytes']);
boxlist.push([11.0,4,'LCD_char','7 bytes']);
boxlist.push([12.0,4,'LCD_char','7 bytes']);
linelist.push([0.0,1,11.5,0]);
linelist.push([6.5,1,11.5,0]);
linelist.push([14.0,1,11.5,0]);
linelist.push([16.0,1,11.5,0]);
linelist.push([17.0,1,11.5,0]);
linelist.push([18.0,1,11.5,0]);
linelist.push([19.5,1,11.5,0]);
linelist.push([21.0,1,11.5,0]);
linelist.push([22.0,1,11.5,0]);
linelist.push([23.0,1,11.5,0]);
linelist.push([1.0,2,6.5,1]);
linelist.push([2.0,2,6.5,1]);
linelist.push([3.0,2,6.5,1]);
linelist.push([6.0,2,6.5,1]);
linelist.push([9.0,2,6.5,1]);
linelist.push([11.0,2,6.5,1]);
linelist.push([13.0,2,14.0,1]);
linelist.push([14.0,2,14.0,1]);
linelist.push([15.0,2,14.0,1]);
linelist.push([18.0,2,18.0,1]);
linelist.push([19.0,2,19.5,1]);
linelist.push([20.0,2,19.5,1]);
linelist.push([2.0,3,2.0,2]);
linelist.push([4.0,3,6.0,2]);
linelist.push([5.0,3,6.0,2]);
linelist.push([6.0,3,6.0,2]);
linelist.push([7.0,3,6.0,2]);
linelist.push([8.0,3,6.0,2]);
linelist.push([9.0,3,9.0,2]);
linelist.push([10.0,3,11.0,2]);
linelist.push([11.0,3,11.0,2]);
linelist.push([12.0,3,11.0,2]);
linelist.push([13.0,3,13.0,2]);
linelist.push([19.0,3,19.0,2]);
linelist.push([7.0,4,7.0,3]);
linelist.push([8.0,4,8.0,3]);
linelist.push([11.0,4,11.0,3]);
linelist.push([12.0,4,12.0,3]);
graphwidth=24;
graphheight=5;
tabledata.push([['main','dest',2,0]]);
tabledata.push([['main','dest',2,1]]);
tabledata.push([['main','arg',1,0]]);
tabledata.push([['DrawStack','character',1,0],['CheckData','input_mode',1,0],['ReadLine','cursor',1,0],['ErrorMsg','error_code',1,0],['ExecToken','token',1,0]]);
tabledata.push([['DrawStack','counter',1,0],['CheckData','y_buff',1,0],['ReadLine','cursor_timer',1,0],['ErrorMsg','msg',2,0],['ExecToken','flags',1,0]]);
tabledata.push([['DrawStack','address',2,0],['CheckData','index',1,0],['ReadLine','arg',1,0],['ErrorMsg','msg',2,1],['ExecToken','temp',1,0]]);
tabledata.push([['DrawStack','address',2,1],['CheckData','which_digit',1,0],['ReadLine','index',1,0],['ExecToken','address',2,0]]);
tabledata.push([['DrawFloat','source',2,0],['CheckData','negative',1,0],['DrawHex','source',2,0],['LCD_print','source',2,0],['DrawString','source',2,0],['LCD_clrscr','counter',1,0],['ExecToken','address',2,1]]);
tabledata.push([['DrawFloat','source',2,1],['CheckData','exp_negative',1,0],['DrawHex','source',2,1],['LCD_print','source',2,1],['DrawString','source',2,1]]);
tabledata.push([['DrawFloat','index',1,0],['CheckData','exp_count',1,0],['DrawHex','arg',1,0],['LCD_print','index',1,0],['DrawString','arg',1,0]]);
tabledata.push([['DrawFloat','arg',1,0],['CheckData','exp_found',1,0],['LCD_print','arg',1,0],['DrawString','index',1,0],['HexLow','digit',1,0],['HexHigh','digit',1,0]]);
tabledata.push([['DrawFloat','sign',1,0],['CheckData','dec_found',1,0],['ReadLine','str_index',1,0],['HexLow','arg',1,0],['HexHigh','arg',1,0]]);
tabledata.push([['DrawFloat','buff',2,0],['CheckData','nonzero_found',1,0]]);
tabledata.push([['DrawFloat','buff',2,1],['CheckData','digit_count',1,0]]);
tabledata.push([['DigitHigh','digit',1,0],['DigitLow','digit',1,0],['BCD_Reverse','source',2,0],['MemCopy','source',2,0]]);
tabledata.push([['LCD_char','c_out',1,0],['BCD_Reverse','source',2,1],['MemCopy','source',2,1]]);
tabledata.push([['LCD_char','pixel_ptr',2,0],['BCD_Reverse','count',1,0],['MemCopy','dest',2,0]]);
tabledata.push([['LCD_char','pixel_ptr',2,1],['MemCopy','dest',2,1]]);
tabledata.push([['LCD_char','pixel_index',1,0],['MemCopy','count',1,0]]);
tabledata.push([['LCD_char','pixel',1,0]]);
tabledata.push([['LCD_char','lc1',1,0]]);
tabledata.push([['LCD_char','lc2',1,0]]);
max_row_length=7;
	
	var c = document.getElementById("GraphCanvas");
	//c.style.padding="0px 50px 50px 0px";	//This is inside the picture, not outside!
	if (graphwidth!=0)
	{
		newwidth=graphwidth*(box_width+box_border_width)-box_border_width+2*screen_border_width;
		c.width=newwidth;
	}
	if (graphheight!=0)
	{
		newheight=graphheight*(box_height+box_border_height)-box_border_height+2*screen_border_height;
		c.height=newheight;
	}
	var ctx = c.getContext("2d");
	ctx.lineWidth=2;
	ctx.textAlign="center";
	ctx.textBaseline="middle";
	
	//Get list of unique box names for assigning colors
	nodenames={};
	for (let i=0;i<boxlist.length;i++)
		//if (!nodenames.includes(boxlist[i][2])) nodenames.push(boxlist[i][2]); //Better to use object
		if (!(boxlist[i][2] in nodenames)) nodenames[boxlist[i][2]]=i;
	
	color_table=[
				//Normal
				"60,120,216",
				"224,102,102",
				"106,168,79",
				"241,194,50",
				"142,124,195",
				"230,145,56",
				"194,123,160",
				"69,129,142",
				"109,158,235",
				//Lighter
				"234,153,153",
				"147,196,125",
				"255,217,102",
				"180,167,214",
				"246,178,107",
				"213,166,189",
				"118,165,175",
				//Lightest
				"164,194,244",
				"182,215,168",
				"255,229,153",
				"249,203,156",
				"162,196,201"
				];
	
	//Assign colors to boxes
	for (let i=0;i<Object.keys(nodenames).length;i++)
	{
		nodenames[Object.keys(nodenames)[i]]="rgba("+color_table[i%color_table.length]+","+box_alpha+")";
	}
	
	//Draw boxes
	for (let i=0;i<boxlist.length;i++)
	{
		let boxx=boxlist[i][0]*(box_width+box_border_width)+screen_border_width;
		let boxy=boxlist[i][1]*(box_height+box_border_height)+screen_border_height;
		ctx.fillStyle=nodenames[boxlist[i][2]];
		ctx.fillRect(boxx,boxy,box_width,box_height);
		ctx.strokeRect(boxx,boxy,box_width,box_height);
		ctx.fillStyle="rgba(0,0,0,1)";
		ctx.font="bold 14px Arial";
		ctx.fillText(boxlist[i][2],boxx+box_width/2,boxy+box_height*0.30);
		ctx.font="12px Arial";
		ctx.fillText(boxlist[i][3],boxx+box_width/2,boxy+box_height*0.75);
	}
	
	//Draw lines between nodes
	for (let i=0;i<linelist.length;i++)
	{
		ctx.beginPath();
		ctx.moveTo(linelist[i][0]*(box_width+box_border_width)+screen_border_width+box_width/2,
			linelist[i][1]*(box_height+box_border_height)+screen_border_height);
		ctx.lineTo(linelist[i][2]*(box_width+box_border_width)+screen_border_width+box_width/2,
			linelist[i][3]*(box_height+box_border_height)+screen_border_height+box_height);
		ctx.stroke();
	}
	
	//Fill out locals assignment table
	let tableHTML="";
	for (let i=0;i<tabledata.length;i++)
	{
		tableHTML+="<tr><td><b>"+i+"</b></td>";
		for (let j=0;j<tabledata[i].length;j++)
		{
			tableHTML+="<td style='background-color:"+nodenames[tabledata[i][j][0]]+"'>";
			tableHTML+=tabledata[i][j][0]+"."+tabledata[i][j][1];
			if (tabledata[i][j][2]!=1) tableHTML+="("+(tabledata[i][j][3]+1)+"/"+tabledata[i][j][2]+")";
			tableHTML+="</td>\n";
		}
		tableHTML+="</tr>";
	}
	document.getElementById('localtable').innerHTML=tableHTML;
</script>

</body>
</html>
